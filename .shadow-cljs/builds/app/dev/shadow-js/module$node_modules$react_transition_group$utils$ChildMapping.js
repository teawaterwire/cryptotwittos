["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-transition-group/utils/ChildMapping.js"],"~:js","shadow$provide.module$node_modules$react_transition_group$utils$ChildMapping=function(b,e,a,d,f){f.__esModule=!0;f.getChildMapping=function(a){if(!a)return a;var b={};c.Children.map(a,function(a){return a}).forEach(function(a){b[a.key]=a});return b};f.mergeChildMappings=function(a,b){function d(d){return b.hasOwnProperty(d)?b[d]:a[d]}a=a||{};b=b||{};var c={},e=[];for(f in a)b.hasOwnProperty(f)?e.length&&(c[f]=e,e=[]):e.push(f);var f=void 0;var g={},h;for(h in b){if(c.hasOwnProperty(h))for(f=0;f<c[h].length;f++)g[c[h][f]]=\nd(c[h][f]);g[h]=d(h)}for(f=0;f<e.length;f++)g[e[f]]=d(e[f]);return g};var c=a(\"module$node_modules$react$index\")}","~:source","shadow$provide[\"module$node_modules$react_transition_group$utils$ChildMapping\"] = function(global,process,require,module,exports) {\n'use strict';\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\n\nvar _react = require('react');\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\nfunction getChildMapping(children) {\n  if (!children) {\n    return children;\n  }\n  var result = {};\n  _react.Children.map(children, function (child) {\n    return child;\n  }).forEach(function (child) {\n    result[child.key] = child;\n  });\n  return result;\n}\n\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    if (next.hasOwnProperty(key)) {\n      return next[key];\n    }\n\n    return prev[key];\n  }\n\n  // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n  var nextKeysPending = {};\n\n  var pendingKeys = [];\n  for (var prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i = void 0;\n  var childMapping = {};\n  for (var nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n    childMapping[nextKey] = getValueForKey(nextKey);\n  }\n\n  // Finally, add the keys which didn't appear before any key in `next`\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["__esModule","getChildMapping","mergeChildMappings"]],"~:compiled-at",1519929620018,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_transition_group$utils$ChildMapping.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,8DAAA,CAAkF,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAwBC,CAAxB,CAA+BC,CAA/B,CAAwC,CAGlIA,CAAAC,WAAA,CAAqB,CAAA,CACrBD,EAAAE,gBAAA,CAWAA,QAAwB,CAACC,CAAD,CAAW,CACjC,GAAI,CAACA,CAAL,CACE,MAAOA,EAET,KAAIC,EAAS,EACbC,EAAAC,SAAAC,IAAA,CAAoBJ,CAApB,CAA8B,QAAS,CAACK,CAAD,CAAQ,CAC7C,MAAOA,EADsC,CAA/C,CAAAC,QAAA,CAEW,QAAS,CAACD,CAAD,CAAQ,CAC1BJ,CAAA,CAAOI,CAAAE,IAAP,CAAA,CAAoBF,CADM,CAF5B,CAKA,OAAOJ,EAV0B,CAVnCJ,EAAAW,mBAAA,CAwCAA,QAA2B,CAACC,CAAD,CAAOC,CAAP,CAAa,CAItCC,QAASA,EAAc,CAACJ,CAAD,CAAM,CAC3B,MAAIG,EAAAE,eAAA,CAAoBL,CAApB,CAAJ,CACSG,CAAA,CAAKH,CAAL,CADT,CAIOE,CAAA,CAAKF,CAAL,CALoB,CAH7BE,CAAA,CAAOA,CAAP,EAAe,EACfC,EAAA,CAAOA,CAAP,EAAe,EAYf,KAAIG,EAAkB,EAAtB,CAEIC,EAAc,EAClB,KAASC,CAAT,GAAoBN,EAApB,CACMC,CAAAE,eAAA,CAAoBG,CAApB,CAAJ,CACMD,CAAAE,OADN,GAEIH,CAAA,CAAgBE,CAAhB,CACA,CAD2BD,CAC3B,CAAAA,CAAA,CAAc,EAHlB,EAMEA,CAAAG,KAAA,CAAiBF,CAAjB,CAIAG,KAAAA,EAAI,IAAK,EACb,KAAIC,EAAe,EAAnB,CACSC,CAAT,KAASA,CAAT,GAAoBV,EAApB,CAA0B,CACxB,GAAIG,CAAAD,eAAA,CAA+BQ,CAA/B,CAAJ,CACE,IAAKF,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBL,CAAA,CAAgBO,CAAhB,CAAAJ,OAAhB,CAAiDE,CAAA,EAAjD,CAEEC,CAAA,CAAaN,CAAA,CAAgBO,CAAhB,CAAA,CAAyBF,CAAzB,CAAb,CAAA;AAA4CP,CAAA,CADvBE,CAAA,CAAgBO,CAAhB,CAAAC,CAAyBH,CAAzBG,CACuB,CAGhDF,EAAA,CAAaC,CAAb,CAAA,CAAwBT,CAAA,CAAeS,CAAf,CAPA,CAW1B,IAAKF,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBJ,CAAAE,OAAhB,CAAoCE,CAAA,EAApC,CACEC,CAAA,CAAaL,CAAA,CAAYI,CAAZ,CAAb,CAAA,CAA+BP,CAAA,CAAeG,CAAA,CAAYI,CAAZ,CAAf,CAGjC,OAAOC,EA7C+B,CAtCxC,KAAIjB,EAASP,CAAA,CAAQ,iCAAR,CAPqH;\",\n\"sources\":[\"node_modules/react-transition-group/utils/ChildMapping.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_transition_group$utils$ChildMapping\\\"] = function(global,process,require,module,exports) {\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.getChildMapping = getChildMapping;\\nexports.mergeChildMappings = mergeChildMappings;\\n\\nvar _react = require('react');\\n\\n/**\\n * Given `this.props.children`, return an object mapping key to child.\\n *\\n * @param {*} children `this.props.children`\\n * @return {object} Mapping of key to child\\n */\\nfunction getChildMapping(children) {\\n  if (!children) {\\n    return children;\\n  }\\n  var result = {};\\n  _react.Children.map(children, function (child) {\\n    return child;\\n  }).forEach(function (child) {\\n    result[child.key] = child;\\n  });\\n  return result;\\n}\\n\\n/**\\n * When you're adding or removing children some may be added or removed in the\\n * same render pass. We want to show *both* since we want to simultaneously\\n * animate elements in and out. This function takes a previous set of keys\\n * and a new set of keys and merges them with its best guess of the correct\\n * ordering. In the future we may expose some of the utilities in\\n * ReactMultiChild to make this easy, but for now React itself does not\\n * directly have this concept of the union of prevChildren and nextChildren\\n * so we implement it here.\\n *\\n * @param {object} prev prev children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @param {object} next next children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @return {object} a key set that contains all keys in `prev` and all keys\\n * in `next` in a reasonable order.\\n */\\nfunction mergeChildMappings(prev, next) {\\n  prev = prev || {};\\n  next = next || {};\\n\\n  function getValueForKey(key) {\\n    if (next.hasOwnProperty(key)) {\\n      return next[key];\\n    }\\n\\n    return prev[key];\\n  }\\n\\n  // For each key of `next`, the list of keys to insert before that key in\\n  // the combined list\\n  var nextKeysPending = {};\\n\\n  var pendingKeys = [];\\n  for (var prevKey in prev) {\\n    if (next.hasOwnProperty(prevKey)) {\\n      if (pendingKeys.length) {\\n        nextKeysPending[prevKey] = pendingKeys;\\n        pendingKeys = [];\\n      }\\n    } else {\\n      pendingKeys.push(prevKey);\\n    }\\n  }\\n\\n  var i = void 0;\\n  var childMapping = {};\\n  for (var nextKey in next) {\\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\\n        var pendingNextKey = nextKeysPending[nextKey][i];\\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\\n      }\\n    }\\n    childMapping[nextKey] = getValueForKey(nextKey);\\n  }\\n\\n  // Finally, add the keys which didn't appear before any key in `next`\\n  for (i = 0; i < pendingKeys.length; i++) {\\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\\n  }\\n\\n  return childMapping;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"__esModule\",\"getChildMapping\",\"children\",\"result\",\"_react\",\"Children\",\"map\",\"child\",\"forEach\",\"key\",\"mergeChildMappings\",\"prev\",\"next\",\"getValueForKey\",\"hasOwnProperty\",\"nextKeysPending\",\"pendingKeys\",\"prevKey\",\"length\",\"push\",\"i\",\"childMapping\",\"nextKey\",\"pendingNextKey\"]\n}\n"]